"""
Asset store.

The purpose of these classes is simple: they must provide the assets
(JavaScript files, CSS files, images, etc.) needed by the applications.

Assets are global, which makes certain things (e.g. exporting a bunch
of apps to the same directory) very simple.

Naturally, different sessions may need different assets with the same
name. Therefore the SessionAssets class provides a way to manage assets
with name mangling.
    
Groups of Model classes can be added as a CSS and JS asset using
``assets.create_module_assets()``, which will select all Model classes
present in the given Python module. Classes used by the session that
are not provided via such a module asset will be added to the index.
"""

import os
import sys
import json
import time
import random
import hashlib
from urllib.request import urlopen
from collections import OrderedDict

from .model import Model, get_model_classes
from . import logger


INDEX = """<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Flexx UI</title>

ASSET-LINK-HOOK

</head>

<body id='body'>

ASSET-CONTENT-HOOK

</body>
</html>
"""

RESET = """
/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */
html
{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,
section,summary{display:block}
audio,canvas,progress,video{display:inline-block;vertical-align:baseline}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
a{background-color:transparent}
a:active,a:hover{outline:0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
h1{font-size:2em;margin:.67em 0}
mark{background:#ff0;color:#000}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-0.5em}
sub{bottom:-0.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:1em 40px}
hr{box-sizing:content-box;height:0}
pre{overflow:auto}
code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}
button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}
button{overflow:visible}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]
{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
input{line-height:normal}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button{height:auto}
input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
textarea{overflow:auto}
optgroup{font-weight:bold}
table{border-collapse:collapse;border-spacing:0}
td,th{padding:0}
"""

HEADER = '/* Autogenerated code from Flexx. Code Subject to the BSD-2-clause license.*/'


reprs = json.dumps


def lookslikeafilename(s):
    # We need this to allow smart-asset setting on legacy Python
    if sys.version_info[0] == 2:
        fchars = '\n\r\x00\x0a'.encode('utf-8')
        if isinstance(s, unicode):  # noqa
            return True
        elif not isinstance(s, bytes):
            return False
        elif any([c in s for c in fchars]):
            return False
        elif len(s) > 500 and s.count('function(') > 5:
            return False  # Looks like a minified file. Bah, rather arbitrary
        else:
            return True
    return isinstance(s, str)


def modname_startswith(x, y):
    return (x + '.').startswith(y + '.')


def create_css_and_js_from_model_classes(classes, css='', js=''):
    # Collect CSS and JS, and filter out empty ones
    css, js = [css], [js]
    for cls in classes:
        css.append(cls.CSS)  # the CSS is '' if not specified for that class
        js.append(cls.JS.CODE)
    css = [i for i in css if i.strip()]
    js = [i for i in js if i.strip()]
    if css:
        css.insert(0, HEADER)
    if js:
        js.insert(0, '"use strict";')
        js.insert(0, HEADER)
    return '\n\n'.join(css) or '\n', '\n\n'.join(js) or '\n'

# todo: what if we constrained the scope of flexx.app and above to browsers, e.g. no node? I wonder if this code would get simpler. Also clientcore et al. can assume the presence of the window object.


class Asset:
    """ Abstract class to represent an asset (JS or CSS) to be included
    on the page, and can have dependencies on other assets.
    
    Parameters:
        name (str): the asset name, e.g. 'foo.css'.
        deps (list): names of assets that this asset depends on.
        code (str): the code for this asset. Multiple pieces of code can be
            given. See the docs of ``code`` for details.
    """
    def __init__(self, name, deps, *code):
        if not name.lower().endwith(('.js', '.css')):
            raise ValueError('Asset is only for .js and .css assets.')
        self._name = str(name)
        self._deps = list(deps) # for elements in code that are modules, the deps are added last-minute
        self._code = list(code)  # elements in code can be Modules, or anythig that can be str-ed
        self._cache = None
    
    def __repr__(self):
        return '<%s %r at 0x%0x>' % (self.__class__.__name__, self._name, id(self))
        
    @property
    def name(self):
        """ The (file) name of this asset.
        """
        return self._name
    
    @property
    def deps(self):
        """ List of dependencies for this JS/CSS asset.
        """
        return self._deps
    
    @property
    def code(self):
        """ The list of code pieces. Can also contain classes or
        functions, which are converted to JS using PyScript, as well
        as Model classes, for which the JS/CSS is extracted.
        """
        return self._code
    
    def to_html(self, embed=False):
        """ Get HTML element tag to include in the document.
        """
        if self.name.lower().endswith('.js'):
            if embed:
                return "<script src=%r></script>" % self.name
            else:
                return '<script>\n' + '\n\n'.join(self.code) + '</script>'
        elif self.name.lower().endswith('.ccs'):
            if embed:
                return "<link rel='stylesheet' type='text/css' href=%r />" % self.name
            else:
                return '<style>\n' + '\n\n'.join(self.code) + '</style>'
        else:
            raise NameError('Assets must be .js or .css')
    
    def to_string(self):
        """ Get the string code provided by this asset. This is what
        gets served to the client.
        """
        if self._cache is None:
            code, names = _get_code_and_names
            self._cache = '\n\n'.join(code)
        return self._cache
    
    def _get_code_and_names(self):
        # todo: add license header and strict mode?
        code = []
        names = []
        for ob in self.code:
            c, name = self._convert_to_code(ob)
            if c:
                code.append(c)
                if name:
                    names.append(name)
        return code, names
    
    def _convert_to_code(self, ob):
        """ Convert object to JS/CSS.
        """
        isjs = self.name.lower().endswith('.js')
        name = None
        
        if isinstance(ob, str):
            pass
        elif isinstance(ob, Model):
            name = ob.__name__
            c = ob.JS.CODE if isjs else ob.CSS
        elif isjs:
            try:
                c = py2js(ob)
            except Exception:
                raise ValueError('Asset %r cannot convert object to JS.' % self.name)
            name = ob.__name__
        else:
            raise ValueError('Asset %r cannot convert non-str object to CSS.' % self.name)
        return c.strip(), name


class RemoteAsset(Asset):
    """ An asset that represents a remote resource (e.g. an asset from a CDN).
    
    Parameters:
        name (str): the asset name, e.g. 'foo.css'.
        deps (list): names of assets that this asset depends on.
        url (str): the asset URL.
    """
    
    def __init__(self, name, deps, url):
        super().__init__(name, deps, url)
    
    @property
    def url(self):
        """ The remote asset URL.
        """
        return self._code[0]
    
    def to_html(self):
        return "<link rel='stylesheet' type='text/css' href=%r />" % self.code[0]
    
    def to_string(self):
        return ''


class ModuleAsset(Asset):
    """ An asset to represent JS code wrapped in a module.
    
    Parameters:
        name (str): the asset name, e.g. 'bar.js'.
        deps (list): names of assets that this asset depends on. Dependencies
            written in the form "foo.js as foo" (i.e. using "as") are imports
            in the module and can be used inside the module under that name.
            The PyScript std is automatically added to the deps.
        exports (list): the names that this JS module should export.
        code (str): the code for this asset. Multiple pieces of code can be
            given. See the docs of ``code`` for details.
    """
    
    def __init__(self, name, deps, exports, *code):
        if not name.lower().endwith('.js'):
            raise ValueError('ModuleAsset is only for .js assets.')
        if not isinstance(exports, list):
            raise ValueError('ModuleAsset.exports must be a list.')
        short_deps = [d.split(' as ')[0] for d in deps]
        super().__init__(name, short_deps, *code)
        self._imports = [d for d in deps if ' as ' in d]
        self._exports = list(exports)
    
    @property
    def exports(self):
        """ List of names that this JS module should export. Is
        auto-populated with the names of classes provided in the
        code list.
        """
        return self._exports
    
    def to_string(self):
        # Use PyScript JSModule to wrap our code
        if self._cache is None:
            code, names = _get_code_and_names
            s = '\n\n'.join(code)
            from ..pyscript.stdlib import JSModule, FUNCTION_PREFIX, METHOD_PREFIX
            s = j.replace(FUNCTION_PREFIX, 'py_.f_').replace(METHOD_PREFIX, 'py_.m_')
            m = JSModule(self.name, s,
                         ['pyscript-std.py as py_'] + self._imports,
                         names + self.exports)
            self._cache = m.saves()
        return self._cache


class AssetStore:
    """ Global provider of client assets (CSS, JavaScript, images, etc.).
    
    Assets are global to the process via the AssetStore instance at
    ``flexx.app.assets``. An asset must be "used" at each ``Session``
    instance where it ought to be loaded. The session can also be used
    to load unique (per session, name mangled) assets.
    """
    
    def __init__(self):
        self._assets = OrderedDict()
        self._data = {}
        # todo: self.add_asset('reset.css', RESET.encode())
    
    def __repr__(self):
        names = ', '.join([repr(name) for name in self._assets])
        return '<AssetStore with assets: %s>' % names
    
    def __getitem__(self, name):
        try:
            return self._assets[name]
        raise KeyError:
            raise KeyError('Asset store does not have asset %r' % name)
    
    def get_asset(self, name, fail=True):
        """ Get the asset corresponding with the given name. Raises a KeyError
        if the asset is unknown, unless fail is False/None.
        """
        try:
            return self._assets[name]
        raise KeyError:
            if fail:
                raise KeyError('Asset store does not have asset %r' % name)
            return None
    
    def get_data(self, name, fail=True):
        """ Get the data corresponding with the given name. Raises a KeyError
        if the data is unknown, unless fail is False/None.
        """
        try:
            return self._data[name]
        raise KeyError:
            if fail:
                raise KeyError('Asset store does not have data %r' % name)
            return None
    
    def get_asset_names(self):
        """ Get a list of all asset names.
        """
        return list(self._assets.keys())
    
    def add_data(self, name, data):
        """ Add data to serve to the client (e.g. images).
        
        Parameters:
            name (str): the name of the data, e.g. 'icon.png'.  If data has
                already been set on this name, it is overwritten.
            data (bytes): the data blob.
        """
        if not isinstance(name, str):
            raise ValueError('AssetStore.add_data() name must be a str.')
        if not isinstance(name, bytes):
            raise ValueError('AssetStore.add_data() data must be a bytes.')
        self._data[name] = data
    
    def add_asset(self, *assets):
        """ Add asset (JS or CSS) to serve the client. It is an error
        to add an asset with a name that is already registered.
        
        Parameters:
            assets (Asset): The asset to add.
        """
        for asset in assets:
            if not isinstance(asset, Asset):
                raise ValueError('AssetStorr.add_asset() needs an Asset instance.')
            if asset.name in self._assets:
                raise ValueError('Asset %r is already set.' % name)
            self._assets[name] = asset
    
   def get_asset_for_class(self, cls):
        """ Get the asset that provides the given Python class.
        """
        for asset in self._assets.values():
            if cls in asset.code:
                return asset
        return None
    
    def get_module_classes(self, module_name):
        """ Get the Model classes corrsesponding to the given module name
        and that are not already provided by an asset.
        """
        # Get classes
        classes = list()
        for cls in get_model_classes():
            if modname_startswith(cls.__module__, module_name):
                if self.get_asset_for_class(cls) is None:
                    classes.append(cls)
        return classes
    
    def export(self, dirname):
        """ Write all assets to the given directory.
        """
        # Normalize and check
        if dirname.startswith('~'):  # pragma: no cover
            dirname = os.path.expanduser(dirname)
        if not os.path.isdir(dirname):
            raise ValueError('dirname %r for export is not a directory.' % dirname)
        # Export all assets
        for fname in self.get_asset_names():
            if not fname.startswith('index-'):
                with open(os.path.join(dirname, fname), 'wb') as f:
                    f.write(self.get_asset(fname).tobytes())

# Our singleton asset store
assets = AssetStore()


class SessionAssets:
    """ Provider for assets for a specific session. Inherited by Session.
    
    Assets included on the document consist of the page assets
    registered on the session, plus the (global) page assets that these
    depend on.
    """
    
    def __init__(self, store=None):  # Allow custom store for testing
        self._store = store if (store is not None) else assets
        assert isinstance(self._store, AssetStore)
        
        self._id = get_random_string()
        
        # Keep track of all assets for this session. Assets that are provided
        # by the asset store have a value of None.
        self._assets = OrderedDict()
        # Data for this session (in addition to the data provided by the store)
        self._data = {}
        # Whether the page has been served already
        self._served = False
        # Cache what classes we know (for performance)
        self._known_classes = set()
        # Model classes that are not in an asset/module
        self._extra_model_classes = []
    
    @property
    def id(self):
        """ The unique identifier of this session.
        """
        return self._id
    
    def get_used_asset_names(self):
        """ Get a list of names of the assets used by this session, in
        the order that they were added.
        """
        return list(self._assets.keys())  # Note: order matters
    
    def _inject_asset_dynamically(self, asset):
        """ Load an asset in a running session.
        """
        logger.debug('Dynamically loading asset %r' % asset.name)
        
        # In notebook?
        from .session import manager  # noqa - avoid circular import
        is_interactive = self is manager.get_default_session()  # e.g. in notebook
        in_notebook = is_interactive and getattr(self, 'init_notebook_done', False)
        
        if in_notebook:
            # Load using IPython constructs
            from IPython.display import display, HTML
            if asset.name.upper().endswith('.JS'):
                display(HTML("<script>%s</script>" % asset.to_string()))
            else:
                display(HTML("<style>%s</style>" % asset.to_string()))
        else:
            # Load using Flexx construct
            suffix = asset.name.split('.')[-1].upper()
            self._send_command('DEFINE-%s %s' % (suffix, asset.to_string()))
    
    def get_asset(self, name):
        """ Get the asset corresponding to the given name. This can be
        an asset local to the session, or a global asset that this session
        is using.
        """
        asset = self._assets.get(name, None)
        if asset is None:
            asset = self._store.get_asset(name, None)
        if asset is None:
            raise ValueError('Unknown session asset: %r' % name)
        return asset
    
    def get_data(self, name):
        """ Get the data corresponding to the given name. This can be
        data local to the session, or global data.
        """
        data = self._data.get(name, None)
        if data is None:
            data = self._store.get_data(name, None)
        if data is None:
            raise ValueError('Unknown session data: %r' % name)
        return data
    
    def use_asset(self, asset):  # -> asset must already exist
        """ Use the given asset in this session. The given asset can
        also be the name of an asset in the asset store. It is safe to
        call this method with an already registered asset.
        """
        # Get the actual asset instance
        if isinstance(asset, str):
            asset = self._store.get_asset(asset, None)
            if asset is None:
                raise ValueError('AssetStorr.add_asset() got unknown asset name.')
        if not isinstance(asset, Asset):
            raise ValueError('Session.use_asset() needs str or Asset.')
        
        # Register or load asset, if necessary
        if asset.name in self._assets:
            cur_asset = self._assets[asset.name]
            if not (cur_asset is None or cur_asset is asset):
                raise ValueError('Cannot register asset under an existing asset name.')
        elif self._served:
            self._inject_asset_dynamically(asset)
        elif asset is self._store.get_asset(asset.name, None):
            self._assets[asset.name] = None  # None means that asset is global
        else:
            self._assets[asset.name] = asset
    
    def provide_data(self, name, data):  # todo: add option to clear data after its loaded?
        """ Add data to serve to the client (e.g. images).
        
        Parameters:
            name (str): the name of the data, e.g. 'icon.png'. If data has
                already been set on this name, it is overwritten.
            data (bytes): the data blob.
        """
        if not isinstance(name, str):
            raise ValueError('Session.provide_data() name must be a str.')
        if not isinstance(name, bytes):
            raise ValueError('Session.provide_data() data must be a bytes.')
        self._data[name] = data
    
    def register_model_class(self, cls):
        """ Ensure that the client knows the given class. A class can
        already be defined via a module asset, or we can add it to a
        pending list if the page has not been served yet. Otherwise it
        needs to be defined dynamically.
        """
        if not (isinstance(cls, type) and issubclass(cls, Model)):
            raise ValueError('Not a Model class')
        
        # Early exit if we know the class already
        if cls in self._known_classes:
            return
        
        # Make sure the base classes are registered first
        for cls2 in cls.mro()[1:]:
            if not issubclass(cls2, Model):  # True if cls2 is *the* Model class
                break
            if cls2 not in self._known_classes:
                self.register_model_class(cls2)
        
        # Make sure that no two models have the same name, or we get problems
        # that are difficult to debug. Unless classes are defined in the notebook.
        same_name = [c for c in self._known_classes if c.__name__ == cls.__name__]
        if same_name:
            from .session import manager  # noqa - avoid circular import
            same_name.append(cls)
            is_interactive = self is manager.get_default_session()  # e.g. in notebook
            is_dynamic_cls = not any([self._store.get_asset_for_class(c)
                                      for c in same_name])
            if not (is_interactive and is_dynamic_cls):
                raise RuntimeError('Cannot have multiple Model classes with the same '
                                   'name unless using interactive session and the '
                                   'classes are dynamically defined: %r' % same_name)
        
        logger.debug('Registering Model class %r' % cls.__name__)
        self._known_classes.add(cls)
        
        # Check if cls is covered by our assets
        asset_js = self._store.get_asset_for_module_class(cls)
        asset_css = self._store.get_asset(asset_js.name[:-2] + 'css', None)
        
        if asset_js:
            # cls is present in a module, add corresponding asset (overwrite ok)
            for asset in [asset_js, asset_css]:
                if asset and asset.name not in self._assets:
                    if self._served:
                        self._inject_asset_dynamically(asset)
                    else:
                        self._assets[asset.name] = None
        elif not self._served:
            # Remember cls, will be served in the index
            self._extra_model_classes.append(cls)
        else:
            # Define class dynamically - assuming we're a session subclass ...
            for asset in [Asset(cls.__name__ + '.js', [], cls.JS.CODE), 
                          Asset(cls.__name__ + '.css', [], cls.CSS)]:
                if asset.code[0].strip():
                    self._inject_asset_dynamically(asset)
    
    def _get_js_and_css_assets(self, with_reset=False):
        """ Get an ordered dictionary with the JS and CSS assets.
        """
        # Create assets from our extra model classes
        if self._extra_model_classes:
            a1 = ModuleAsset('extra-classes.js', [], [], *self._extra_model_classes)
            a2 = ModuleAsset('extra-classes.css', [], [], *self._extra_model_classes)
            self.use_asset(a1)
            self.add_asset(a2)
        
        # make sure we wont append to _extra_model_classes anymore :)
        self._extra_model_classes = None
        # Mark that any new assets dont make it into the currently served page
        self._served = True
        
        # todo: RESOLVE assets
        # Collect assets
        d = OrderedDict()
        if with_reset:
            fname = 'reset.css'
            d[fname] = self._store.get_asset(fname).to_string()
        for fname in self.get_used_asset_names():
            if fname.endswith('.js') or fname.endswith('.css'):
                d[fname] = self._store.get_asset(fname).to_string()
        return d
    
    def get_js_only(self):
        """ Get all JS assets as a single string. Intended for apps
        that make no use of CSS (like in Node).
        """
        js = []
        for fname, code in self._get_js_and_css_assets().items():
            if fname.endswith('.js'):
                js.append(code)
        return '\n\n'.join(js)
    
    def get_assets_as_html(self):
        """ Get a list of "<script>" and "<style>" html elements (as
        strings) representing the assets. No reset.css is included, nor
        any remote assets.
        """
        content_assets = []
        for fname, code in self._get_js_and_css_assets(False).items():
            if not code.strip():  # pragma: no cover
                continue
            elif fname.endswith('.css'):
                t = "<style>\n/* CSS for %s */\n%s\n</style>"
                content_assets.append(t % (fname, code))
            else:
                if fname == 'pyscript-std.js':
                    # <script> elements might be embedded in a sub DOM element,
                    # which wont expose vars in global scope bc of "use strict"
                    code = code.replace('\nvar _py', '\nwindow._py')
                t = "<script>\n/* JS for %s */\n%s\n</script>"
                content_assets.append(t % (fname, code))
        return content_assets
    
    def get_page(self, single=False):
        """ Get the string for the HTML page to render this session's app.
        """
        return self._get_page(single)
    
    def get_page_for_export(self, commands, single=False):
        """ Get the string for an exported HTML page (to run without a server).
        """
        # Create lines to init app
        lines = []
        lines.append('flexx.is_exported = true;\n')
        lines.append('flexx.runExportedApp = function () {')
        lines.extend(['    flexx.command(%s);' % reprs(c) for c in commands])
        lines.append('};\n')
        
        # Create an extra asset for the export
        self.add_asset('index-export.js', '\n'.join(lines).encode())
        return self._get_page(single)
    
    def _get_page(self, single):
        """ This code takes the template, the collected JS and CSS, and
        composes an index page to serve/export.
        """
        # Init source code from template
        link_assets = []
        content_assets = []
        
        # Collect JS and CSS
        for fname, code in self._get_js_and_css_assets(True).items():
            if not code.strip():  # pragma: no cover
                continue
            elif single or fname.startswith('index-'):
                if fname.endswith('.css'):
                    t = "<style>\n/* CSS for %s */\n%s\n</style>"
                    content_assets.append(t % (fname, code))
                else:
                    t = "<script>\n/* JS for %s */\n%s\n</script>"
                    content_assets.append(t % (fname, code))
            elif fname.startswith('session') and fname.endswith('.js'):
                link_assets.append("    <script>%s</script>" % code)
            else:
                if fname.endswith('.css'):
                    t = "    <link rel='stylesheet' type='text/css' href='%s' />"
                    link_assets.append(t % fname)
                else:
                    t = "    <script src='%s'></script>"
                    link_assets.append(t % fname)
        
        # # Collect remote assets. These come after the other assets.
        # # Does that make sense, or is it better to maintain order?
        # for url in self._remote_asset_names:
        #     if url.endswith('.css'):
        #         t = "    <link rel='stylesheet' type='text/css' href='%s' />"
        #         link_assets.append(t % url)
        #     else:
        #         t = "    <script src='%s'></script>"
        #         link_assets.append(t % url)
        
        # Compose index page
        src = INDEX
        src = src.replace('ASSET-LINK-HOOK', '\n'.join(link_assets))
        src = src.replace('ASSET-CONTENT-HOOK', '\n'.join(content_assets))
        
        return src


# Use the system PRNG for session id generation (if possible)
# NOTE: secure random string generation implementation is adapted
#       from the Django project. 

def get_random_string(length=24, allowed_chars=None):
    """ Produce a securely generated random string.
    
    With a length of 12 with the a-z, A-Z, 0-9 character set returns
    a 71-bit value. log_2((26+26+10)^12) =~ 71 bits
    """
    allowed_chars = allowed_chars or ('abcdefghijklmnopqrstuvwxyz' +
                                      'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
    try:
        srandom = random.SystemRandom()
    except NotImplementedError:
        srandom = random
        logger.warn('Falling back to less secure Mersenne Twister random string.')
        bogus = "%s%s%s" % (random.getstate(), time.time(), 'sdkhfbsdkfbsdbhf')
        random.seed(hashlib.sha256(bogus.encode()).digest())

    return ''.join(srandom.choice(allowed_chars) for i in range(length))
